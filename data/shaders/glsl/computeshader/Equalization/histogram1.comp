#version 450

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, rgba8) uniform readonly image2D inputImage;
#define HISTO_SIZE 256

layout (binding = 1) buffer HistoEq
{
	uint histoBin[HISTO_SIZE];
    float cdf[HISTO_SIZE];
    uint sum;

} histoEq;

shared uint s_histo[HISTO_SIZE];
void main()
{
    if(gl_LocalInvocationIndex < HISTO_SIZE)
        s_histo[gl_LocalInvocationIndex] = 0;
    memoryBarrierShared();
    barrier();

    uvec2 imageDim = imageSize(inputImage) ;

    uint tid = gl_LocalInvocationIndex;
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    //uint stride = gl_WorkGroupSize.x * gl_WorkGroupSize.y;
    if(x < imageDim.x && y < imageDim.y)
    {
       vec3 pixel = imageLoad(inputImage, ivec2(x,y)).rgb;
       float Y = 255.0 * (0.299 * pixel.r + 0.587 * pixel.g + 0.114 *  pixel.b);
       uint v = clamp(uint(Y),0,255);
       atomicAdd(s_histo[uint(Y)],1);
    }
    memoryBarrierShared();
    barrier();

//    if(gl_LocalInvocationIndex < HISTO_SIZE)
//    {
//          atomicAdd(histoEq.histoBin[gl_LocalInvocationIndex]
//            , s_histo[gl_LocalInvocationIndex]);
//    }

    if ( gl_GlobalInvocationID.x == 0 &&  gl_GlobalInvocationID.y == 0) 
    {
        for(int i = 0 ; i < HISTO_SIZE ; ++i)
        {
             atomicAdd(histoEq.histoBin[i]
            , s_histo[i]);
        }
    }

}
 	
 
 
 
