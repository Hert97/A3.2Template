#version 450

layout (local_size_x = 1024, local_size_y = 1) in;
layout (binding = 0, rgba8) uniform readonly image2D inputImage;
layout (binding = 2, rgba8) uniform image2D resultImage;
#define HISTO_SIZE 256

layout (binding = 1) buffer HistoEq
{
	uint histoBin[HISTO_SIZE];
    float cdf[HISTO_SIZE];
    //uint sum;

} histoEq;

shared float s_cdfMinY;

float CorrectComp(in float cdfVal , in float cdfMin )
{
    return clamp(255 *((cdfVal ) - ( cdfMin ) ) / ( 1.0 - (cdfMin) ) , 0.0 , 255.0 );
}

void main()
{
    uint tid = gl_GlobalInvocationID.x ;
    uvec2 imageDim = imageSize(inputImage) ;
    
    if(tid == 0)
        s_cdfMinY = histoEq.histoBin[0];
  
    if(tid < imageDim.x * imageDim.y )
    {
       //make thread into 2D
       uint x = tid % imageDim.x;
       uint y = tid / imageDim.x;
       vec3 pixel = imageLoad(inputImage, ivec2(x,y)).rgb;
       //get index to cdf by computing the Y from rgb
       float index = 255.0 * (0.299 * pixel.r + 0.587 * pixel.g + 0.114 *  pixel.b);
       float Y = CorrectComp(histoEq.cdf[uint(index)],s_cdfMinY) / 255.0;
       float U = (-0.169 * pixel.r - 0.331 * pixel.g + 0.499 *  pixel.b) ;
       float V = (0.499 * pixel.r  - 0.418 * pixel.g + 0.0813 *  pixel.b) ;

       vec3 fColor = clamp(vec3(Y + 1.402 * V, Y - 0.334 * U - 0.714 * V, Y + 1.772 * U ),vec3(0.0),vec3(1.0));
    
       imageStore(resultImage, ivec2(x,y), vec4(fColor,1.0));
    }

  
}
 	
 
 
 
